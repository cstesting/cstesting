<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Installation | CSTesting</title>
  <link rel="stylesheet" href="styles.css" />
  <link rel="stylesheet" href="docs.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
</head>
<body class="docs-page">
  <a href="#main" class="skip-link">Skip to main content</a>

  <header class="header">
    <div class="header-inner">
      <button class="nav-toggle" aria-label="Toggle navigation" aria-expanded="false">
        <span></span><span></span><span></span>
      </button>
      <a href="index.html" class="logo">
        <span class="logo-icon" aria-hidden="true">◆</span>
        <span id="logo-text">CSTesting</span>
      </a>
      <nav class="nav" aria-label="Main">
        <a href="index.html#features">Features</a>
        <a href="docs.html" class="nav-active">Docs</a>
        <a href="index.html#community">Community</a>
        <div class="nav-dropdown">
          <button type="button" class="nav-dropdown-trigger" aria-expanded="false" aria-haspopup="true" aria-controls="youtube-menu" id="youtube-trigger">YouTube</button>
          <div class="nav-dropdown-menu" id="youtube-menu" role="menu" aria-labelledby="youtube-trigger">
            <a href="https://www.youtube.com/@testingtutorialspoint" role="menuitem" class="nav-dropdown-item" target="_blank" rel="noopener noreferrer">testingtutorialspoint</a>
            <a href="https://www.youtube.com/@cstechnologiestelugu1988" role="menuitem" class="nav-dropdown-item" target="_blank" rel="noopener noreferrer">cstechnologiestelugu</a>
          </div>
        </div>
      </nav>
      <div class="header-actions">
        <button class="search-btn" aria-label="Search (Command+K)">Search</button>
        <a href="index.html#get-started" class="btn btn-primary">Get started</a>
      </div>
    </div>
  </header>

  <div class="docs-layout">
    <button type="button" class="docs-sidebar-toggle" aria-label="Toggle docs menu" aria-expanded="false">Docs menu</button>
    <aside class="docs-sidebar" id="docs-sidebar" aria-label="Documentation navigation">
      <nav class="docs-nav">
        <div class="docs-nav-group">
          <button type="button" class="docs-nav-group-title" aria-expanded="true" aria-controls="docs-group-getting-started" id="docs-group-getting-started-btn">
            <span>Getting Started</span>
            <span class="docs-nav-group-chevron" aria-hidden="true"></span>
          </button>
          <div class="docs-nav-group-links" id="docs-group-getting-started">
            <a href="docs.html#installation" class="docs-nav-link docs-nav-link--active">Installation</a>
            <a href="docs.html#writing-tests" class="docs-nav-link">Writing tests</a>
            <a href="docs.html#running-tests" class="docs-nav-link">Running tests</a>
            <a href="docs.html#page-object-model" class="docs-nav-link">Page Object Model (POM)</a>
            <a href="docs.html#config-driven-tests" class="docs-nav-link">Config-driven tests</a>
            <a href="docs.html#typescript" class="docs-nav-link">TypeScript</a>
          </div>
        </div>
        <div class="docs-nav-group collapsed">
          <button type="button" class="docs-nav-group-title" aria-expanded="false" aria-controls="docs-group-annotations" id="docs-group-annotations-btn">
            <span>Annotations</span>
            <span class="docs-nav-group-chevron" aria-hidden="true"></span>
          </button>
          <div class="docs-nav-group-links" id="docs-group-annotations">
            <a href="docs.html#config-file-annotations" class="docs-nav-link">Config-file annotations</a>
            <a href="docs.html#test-code-annotations" class="docs-nav-link">Test-code annotations</a>
            <a href="docs.html#assertions" class="docs-nav-link">Assertions</a>
            <a href="docs.html#other-features" class="docs-nav-link">Other features</a>
          </div>
        </div>
        <div class="docs-nav-group collapsed">
          <button type="button" class="docs-nav-group-title" aria-expanded="false" aria-controls="docs-group-api" id="docs-group-api-btn">
            <span>API</span>
            <span class="docs-nav-group-chevron" aria-hidden="true"></span>
          </button>
          <div class="docs-nav-group-links" id="docs-group-api">
            <a href="docs.html#test-structure" class="docs-nav-link">Test structure</a>
            <a href="docs.html#browser-api" class="docs-nav-link">Browser API</a>
          </div>
        </div>
        <div class="docs-nav-group collapsed">
          <button type="button" class="docs-nav-group-title" aria-expanded="false" aria-controls="docs-group-guides" id="docs-group-guides-btn">
            <span>Guides</span>
            <span class="docs-nav-group-chevron" aria-hidden="true"></span>
          </button>
          <div class="docs-nav-group-links" id="docs-group-guides">
            <a href="docs.html#actions" class="docs-nav-link">Actions</a>
            <a href="docs.html#dropdown" class="docs-nav-link">Dropdown</a>
            <a href="docs.html#checkbox-and-radio" class="docs-nav-link">Checkbox and radio</a>
            <a href="docs.html#element-state" class="docs-nav-link">Element state</a>
            <a href="docs.html#locators" class="docs-nav-link">Locators</a>
            <a href="docs.html#frames" class="docs-nav-link">Frames</a>
            <a href="docs.html#dialogs" class="docs-nav-link">Dialogs</a>
            <a href="docs.html#navigations" class="docs-nav-link">Navigations</a>
          </div>
        </div>
      </nav>
    </aside>

    <main id="main" class="docs-content">
      <div class="docs-content-inner">
        <p class="docs-platform-badge" id="docs-platform-badge" style="display: none;"></p>

        <!-- Shown when selected platform has no docs yet (Java, Python, C#) -->
        <div class="docs-coming-soon-block" id="docs-coming-soon-block" style="display: none;">
          <h1>Documentation coming soon</h1>
          <p class="docs-coming-soon-message" id="docs-coming-soon-message">Documentation for CSTesting for this platform is coming soon.</p>
          <p>Use Node.js documentation for now, or check back later.</p>
          <p>
            <a href="docs.html" class="btn btn-primary docs-coming-soon-btn" id="docs-switch-nodejs">View Node.js docs</a>
            <a href="index.html" class="btn btn-outline docs-coming-soon-btn">Back to home</a>
          </p>
        </div>

        <!-- Full docs: shown only for NodeJS (or when no platform selected) -->
        <div class="docs-main-content" id="docs-main-content">
        <h1 class="docs-section-heading">Getting Started</h1>

        <h2 id="installation">Installation</h2>
        <h3>Introduction</h3>
        <p id="docs-intro">CSTesting is a simple, extensible Node.js testing framework. It bundles a test runner, assertions, and CDP-based browser automation (no Playwright or Cypress required).</p>
        <p><strong>You will learn</strong></p>
        <ul>
          <li>How to install CSTesting</li>
          <li>What's installed</li>
          <li>How to run the example test</li>
        </ul>

        <h3>Installing CSTesting</h3>
        <p>Get started by installing CSTesting in your project.</p>
        <h3>Using npm</h3>
        <pre><code>npm install cstesting</code></pre>
        <p>Or add to an existing project:</p>
        <pre><code>npm install cstesting</code></pre>

        <h3>What's Installed</h3>
        <p>After installation you can run tests with:</p>
        <pre><code>npx cstesting
npx cstesting "**/*.test.js"
npx cst</code></pre>
        <p>Use in code:</p>
        <pre><code>const { describe, it, expect, createBrowser } = require('cstesting');</code></pre>

        <h2 id="writing-tests">Writing tests</h2>
        <p>Create a test file (e.g. <code>math.test.js</code>):</p>
        <pre><code>const { describe, it, expect } = require('cstesting');

describe('Math', () => {
  it('adds numbers', () => {
    expect(1 + 1).toBe(2);
  });

  it('compares objects', () => {
    expect({ a: 1 }).toEqual({ a: 1 });
  });
});</code></pre>

        <h2 id="running-tests">Running tests</h2>
        <pre><code>npx cstesting
npx cstesting "**/*.test.js"
npx cstesting tests/</code></pre>

        <h2 id="page-object-model">Page Object Model (POM)</h2>
        <p>After installing, scaffold a pages and tests structure with sample code:</p>
        <pre><code>npx cstesting init
# or
npx cst init</code></pre>
        <p>This creates:</p>
        <ul>
          <li><strong><code>pages/</code></strong> — page objects (e.g. HomePage.js) that wrap selectors and actions</li>
          <li><strong><code>tests/</code></strong> — sample test file (home.test.js) that uses the page object</li>
        </ul>
        <p>Then run: <code>npx cstesting tests/</code></p>

        <h2 id="config-driven-tests">Config-driven tests (single file → run → report)</h2>
        <p>Run tests from a config file without writing code. One function: pick file, run steps, get report.</p>
        <p>This is not available in any other automation tool (Selenium, Playwright, Cypress, etc.). Only CSTesting lets you define and run full flows from a simple config file and get a single test case with a report. Right now we support login-style flows (goto, type into inputs, click). We will add all types of actions (dropdowns, checkboxes, waits, assertions, etc.) so you can cover any scenario from config alone.</p>

        <h3>Config format (one step per line)</h3>
        <ul>
          <li><strong><code># Test case name</code></strong> — starts a single test case; all following steps belong to it until the next <code>#</code> (report shows one test per section)</li>
          <li><strong><code>headless=false</code></strong> or <strong><code>headed=true</code></strong> — open browser in headed mode (visible window; default is headless)</li>
          <li><strong><code>goto:&lt;url&gt;</code></strong> — open URL</li>
          <li><strong><code>&lt;label&gt;:&lt;locator&gt;=value:&lt;text&gt;</code></strong> — type text into element (e.g. <code>username:#email=value:john</code>)</li>
          <li><strong><code>click=&lt;locator&gt;</code></strong> — click element (e.g. <code>click=button[type="submit"]</code>)</li>
        </ul>

        <h3>Example <code>login.conf</code></h3>
        <pre><code># Login Page (visible browser)
headed=true
goto:https://example.com/login
username:#email=value:user@test.com
password:#password=value:secret
click=button[type="submit"]</code></pre>

        <p>Run and get report:</p>
        <pre><code>npx cstesting run login.conf
# or
npx cstesting login.conf</code></pre>
        <p>All steps under a <code>#</code> section run as one test case in order; pass/fail is for the whole case and the HTML report shows one row per test case with expandable steps.</p>

        <h3>Programmatic</h3>
        <pre><code>const { runConfigFile } = require('cstesting');
const result = await runConfigFile('login.conf');</code></pre>

        <h2 id="typescript">TypeScript</h2>
        <p><strong>Install</strong></p>
        <pre><code>npm install cstesting
npm install -D ts-node typescript</code></pre>
        <p><strong>Running</strong></p>
        <pre><code>npx cstesting tests/</code></pre>
        <p><strong>Test files:</strong> You can write tests in <code>.test.ts</code> or <code>.spec.ts</code>. The CLI discovers them the same as <code>.test.js</code> / <code>.spec.js</code>.</p>
        <p><strong>Running <code>.ts</code> tests:</strong> Install <code>ts-node</code> in your project. If you don't use <code>ts-node</code>, compile TypeScript to JavaScript first (<code>tsc</code>) and run the generated <code>.js</code> files.</p>

        <h1 class="docs-section-heading">Annotations &amp; features</h1>

        <h2 id="config-file-annotations">1. Config-file annotations (config-driven tests)</h2>
        <table class="docs-table">
          <thead>
            <tr>
              <th>Annotation</th>
              <th>Description</th>
              <th>Example</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code># Test case name</code></td>
              <td>Starts a single test case; all following steps belong to it until the next <code>#</code>. Report shows one test per section.</td>
              <td><code># Login Page - Mercury Tours</code></td>
            </tr>
            <tr>
              <td><code>headed=true</code></td>
              <td>Run browser in headed mode (visible window).</td>
              <td><code>headed=true</code></td>
            </tr>
            <tr>
              <td><code>headless=false</code></td>
              <td>Same as headed mode.</td>
              <td><code>headless=false</code></td>
            </tr>
            <tr>
              <td><code>goto:&lt;url&gt;</code></td>
              <td>Navigate to URL.</td>
              <td><code>goto:https://example.com/login</code></td>
            </tr>
            <tr>
              <td><code>&lt;label&gt;:&lt;locator&gt;=value:&lt;text&gt;</code></td>
              <td>Type text into element.</td>
              <td><code>username:[name="userName"]=value:mercury</code></td>
            </tr>
            <tr>
              <td><code>click=&lt;locator&gt;</code></td>
              <td>Click element.</td>
              <td><code>click=[name="submit"]</code></td>
            </tr>
          </tbody>
        </table>
        <p><strong>Note:</strong> More action types (dropdowns, checkboxes, waits, assertions, etc.) are planned.</p>

        <h2 id="test-code-annotations">2. Test-code annotations (describe / it / hooks)</h2>
        <ul>
          <li><code>describe</code>, <code>it</code>, <code>describe.only</code>, <code>it.only</code>, <code>describe.skip</code>, <code>it.skip</code></li>
          <li><code>beforeAll</code>, <code>afterAll</code>, <code>beforeEach</code>, <code>afterEach</code></li>
          <li><code>step(name)</code> for the HTML report</li>
        </ul>

        <h2 id="assertions">3. Assertions (expect)</h2>
        <p><code>toBe</code>, <code>toEqual</code>, <code>toBeTruthy</code> / <code>toBeFalsy</code>, <code>toBeNull</code> / <code>toBeDefined</code> / <code>toBeUndefined</code>, <code>toThrow</code>, <code>toBeGreaterThan</code> / <code>toBeLessThan</code>, <code>toContain</code>, <code>toHaveLength</code>, <code>expect(x).not.*</code></p>

        <h2 id="other-features">4. Other features</h2>
        <ul>
          <li>TypeScript support (types + <code>.test.ts</code> with ts-node)</li>
          <li>Page Object Model (<code>npx cstesting init</code>)</li>
          <li>Browser API (CDP-based)</li>
          <li>HTML report and config run (<code>npx cstesting run login.conf</code>)</li>
        </ul>

        <h1 class="docs-section-heading">API</h1>
        <h2 id="test-structure">Test structure</h2>
        <ul>
          <li><strong><code>describe(name, fn)</code></strong> — define a suite (nested suites supported)</li>
          <li><strong><code>it(name, fn)</code></strong> — define a test (async supported)</li>
          <li><strong><code>describe.only</code></strong> / <strong><code>it.only</code></strong> — run only this suite/test</li>
          <li><strong><code>describe.skip</code></strong> / <strong><code>it.skip</code></strong> — skip this suite/test</li>
        </ul>

        <h2 id="browser-api">Browser API</h2>
        <p>Use <code>createBrowser()</code> for CDP-based browser automation. Requires Chrome or Chromium.</p>
        <pre><code>const { createBrowser, describe, it, expect, beforeAll, afterAll } = require('cstesting');

describe('My site', () => {
  let browser;

  beforeAll(async () => {
    browser = await createBrowser({ headless: true });
  });

  afterAll(async () => {
    await browser.close();
  });

  it('loads the page', async () => {
    await browser.goto('https://example.com');
    const html = await browser.content();
    expect(html).toContain('Example Domain');
  });
});</code></pre>

        <h2 id="actions">Actions</h2>
        <h3>Introduction</h3>
        <p>Playwright can interact with HTML Input elements such as text inputs, checkboxes, radio buttons, select options, mouse clicks, type characters, keys and shortcuts as well as upload files and focus elements.</p>

        <h3>Text input – ways to handle</h3>
        <p><strong>CSTesting supports 5 ways to handle text input</strong> (typing into inputs):</p>
        <hr />

        <h4>1. Config file (no code)</h4>
        <p>In a <code>.conf</code> file, one line per field. Format: <strong><code>&lt;label&gt;:&lt;locator&gt;=value:&lt;text&gt;</code></strong></p>
        <pre><code># Login Page
username:[name="userName"]=value:mercury
password:[name="password"]=value:secret</code></pre>
        <p>Run: <code>npx cstesting run login.conf</code></p>
        <hr />

        <h4>2. browser.type(selector, text)</h4>
        <p>Direct API: pass a CSS selector (or shorthand) and the text.</p>
        <pre><code>const { createBrowser } = require('cstesting');
const browser = await createBrowser({ headless: true });
await browser.goto('https://example.com/login');
await browser.type('[name="userName"]', 'mercury');
await browser.type('[name="password"]', 'secret');
await browser.close();</code></pre>
        <p><strong>Locator shorthand:</strong> <code>name="userName"</code> → <code>[name="userName"]</code>, <code>id="email"</code> → <code>[id="email"]</code>, etc.</p>
        <hr />

        <h4>3. browser.locator(selector).type(text)</h4>
        <p>Use a locator when you need to chain (e.g. type then press key) or target one of multiple elements.</p>
        <pre><code>await browser.goto('https://www.google.com');
const searchBox = browser.locator('[name="q"]');
await searchBox.type('CSTesting');
await searchBox.pressKey('Enter');</code></pre>
        <p><strong>When multiple elements match:</strong> use <code>.first()</code>, <code>.last()</code>, or <code>.nth(index)</code>:</p>
        <pre><code>await browser.locator('input').first().type('hello');
await browser.locator('input').nth(1).type('world');</code></pre>
        <hr />

        <h4>4. browser.getByAttribute(attr, value).type(text)</h4>
        <p>Type into an element found by attribute (same locator API).</p>
        <pre><code>const input = browser.getByAttribute('name', 'userName');
await input.type('mercury');</code></pre>
        <hr />

        <h4>5. Page Object (wrap in a class)</h4>
        <p>Centralize selectors and typing in a page class; use it in tests.</p>
        <p><strong>pages/LoginPage.js:</strong></p>
        <pre><code>class LoginPage {
  constructor(browser) {
    this.browser = browser;
  }
  async typeUsername(value) {
    await this.browser.type('[name="userName"]', value);
  }
  async typePassword(value) {
    await this.browser.type('[name="password"]', value);
  }
  async submit() {
    await this.browser.click('[name="submit"]');
  }
}
module.exports = LoginPage;</code></pre>
        <p><strong>Test:</strong></p>
        <pre><code>const { createBrowser, describe, it, beforeAll, afterAll } = require('cstesting');
const LoginPage = require('./pages/LoginPage');

describe('Login', () => {
  let browser, page;
  beforeAll(async () => {
    browser = await createBrowser({ headless: true });
    page = new LoginPage(browser);
  });
  afterAll(async () => await browser.close());

  it('logs in', async () => {
    await browser.goto('https://example.com/login');
    await page.typeUsername('mercury');
    await page.typePassword('secret');
    await page.submit();
  });
});</code></pre>
        <hr />

        <p><strong>Summary</strong></p>
        <table class="docs-table">
          <thead>
            <tr>
              <th>#</th>
              <th>Way</th>
              <th>Use when</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>1</td>
              <td>Config file <code>label:locator=value:text</code></td>
              <td>No code; run flows from .conf</td>
            </tr>
            <tr>
              <td>2</td>
              <td><code>browser.type(selector, text)</code></td>
              <td>Simple one-off typing</td>
            </tr>
            <tr>
              <td>3</td>
              <td><code>browser.locator(selector).type(text)</code></td>
              <td>Chain with pressKey; use .first()/.nth()</td>
            </tr>
            <tr>
              <td>4</td>
              <td><code>browser.getByAttribute(attr, value).type(text)</code></td>
              <td>Find by attribute, then type</td>
            </tr>
            <tr>
              <td>5</td>
              <td>Page Object method</td>
              <td>Reuse and maintain selectors in one place</td>
            </tr>
          </tbody>
        </table>

        <h2 id="dropdown">Dropdown – ways to handle</h2>
        <p>CSTesting supports <strong>three ways</strong> to select an option in a <code>&lt;select&gt;</code> dropdown:</p>
        <hr />

        <h3>1. By visible text (label)</h3>
        <p>Match the option by the text the user sees. Use when the visible label is stable and you want tests to read clearly.</p>
        <pre><code>const { createBrowser } = require('cstesting');
const browser = await createBrowser({ headless: true });
await browser.goto('https://example.com/form');
// Select the option whose visible text is "Europe"
await browser.select('#country', { label: 'Europe' });
await browser.close();</code></pre>
        <p><strong>Locator shorthand:</strong> <code>name="country"</code> → <code>[name="country"]</code>, <code>id="country"</code> → <code>#country</code>, etc.</p>
        <hr />

        <h3>2. By index (0-based)</h3>
        <p>Select by the position of the option. Use when the order is fixed and you don't care about the exact text or value.</p>
        <pre><code>// Select the first option (index 0)
await browser.select('#country', { index: 0 });
// Select the third option (index 2)
await browser.select('#country', { index: 2 });</code></pre>
        <p>When multiple <code>&lt;select&gt;</code> elements match the selector, use a locator with <code>.first()</code>, <code>.last()</code>, or <code>.nth(n)</code>:</p>
        <pre><code>await browser.locator('select.region').first().select({ index: 1 });</code></pre>
        <hr />

        <h3>3. By value</h3>
        <p>Select by the option's <code>value</code> attribute. Use when the value is stable (e.g. API or backend contract) and may differ from the visible text.</p>
        <pre><code>// Select the option with value="uk"
await browser.select('#country', { value: 'uk' });</code></pre>
        <hr />

        <h3>4. Multi-select dropdown</h3>
        <p>For <code>&lt;select multiple&gt;</code>, pass an <strong>array</strong> of options. The current selection is cleared and replaced with the given set. You can mix label, index, and value in the same call.</p>
        <pre><code>// Select multiple options by visible text
await browser.select('#tags', [
  { label: 'JavaScript' },
  { label: 'Testing' },
]);

// Or by value
await browser.select('#tags', [{ value: 'js' }, { value: 'test' }]);

// Or by index (e.g. first and third option)
await browser.select('#tags', [{ index: 0 }, { index: 2 }]);

// Mix: one by label, one by value
await browser.select('#tags', [{ label: 'JavaScript' }, { value: 'e2e' }]);</code></pre>
        <p>With a locator: <code>browser.locator('select#tags').select([{ label: 'A' }, { label: 'B' }])</code>. A single <code>change</code> event is dispatched after all options are set.</p>

        <h2 id="checkbox-and-radio">Checkbox and radio</h2>
        <p>Use <strong><code>check(selector)</code></strong> and <strong><code>uncheck(selector)</code></strong> for <code>&lt;input type="checkbox"&gt;</code> and <code>&lt;input type="radio"&gt;</code>. The element must be an <code>INPUT</code> with <code>type</code> <code>checkbox</code> or <code>radio</code>; otherwise a clear error is thrown. A <code>change</code> and <code>click</code> event are dispatched after setting <code>checked</code>.</p>

        <h3>Checkbox</h3>
        <pre><code>// Check a checkbox (e.g. "I agree")
await browser.check('#agree');
// or by name
await browser.check('name="terms"');

// Uncheck
await browser.uncheck('#newsletter');

// When multiple match, use a locator
await browser.locator('input[type="checkbox"]').nth(1).check();</code></pre>

        <h3>Radio button</h3>
        <p>Select one option in a group by <strong>checking</strong> the radio you want. Other radios with the same <code>name</code> are unchecked by the browser.</p>
        <pre><code>// Select "Yes"
await browser.check('#choice-yes');
// or by value with a selector that targets that option
await browser.check('input[name="choice"][value="yes"]');

// To switch selection, check another radio (no need to uncheck the previous one)
await browser.check('input[name="choice"][value="no"]');</code></pre>
        <p><strong>Note:</strong> <code>uncheck</code> on a radio sets that radio to unchecked. Usually you just <code>check</code> another radio in the group instead.</p>

        <h3>Summary</h3>
        <table class="docs-table">
          <thead>
            <tr>
              <th>Action</th>
              <th>Method</th>
              <th>Use when</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Check</td>
              <td><code>browser.check(selector)</code></td>
              <td>Check a checkbox or select a radio option</td>
            </tr>
            <tr>
              <td>Uncheck</td>
              <td><code>browser.uncheck(selector)</code></td>
              <td>Uncheck a checkbox</td>
            </tr>
            <tr>
              <td>With locator</td>
              <td><code>browser.locator(selector).check()</code> / <code>.uncheck()</code></td>
              <td>When multiple elements match (use <code>.first()</code>, <code>.nth(n)</code>)</td>
            </tr>
          </tbody>
        </table>

        <h2 id="element-state">Element state: isVisible, isDisabled, isEditable, isSelected</h2>
        <p>Use these to assert or branch on element state. All return <code>Promise&lt;boolean&gt;</code> and use the same locator rules (strict mode, <code>.first()</code>, <code>.nth(n)</code>).</p>

        <h3>isVisible(selector)</h3>
        <p><code>true</code> if the element exists and is visible: not <code>display:none</code>, not <code>visibility:hidden</code>, opacity &gt; 0, and has non-zero width/height.</p>
        <pre><code>const visible = await browser.isVisible('#submit');
expect(visible).toBe(true);

// With locator (e.g. when multiple match)
const firstVisible = await browser.locator('.btn').first().isVisible();</code></pre>

        <h3>isDisabled(selector)</h3>
        <p><code>true</code> if the element has <code>disabled === true</code> (e.g. <code>&lt;input disabled&gt;</code>, <code>&lt;button disabled&gt;</code>).</p>
        <pre><code>const disabled = await browser.isDisabled('#submit');
expect(disabled).toBe(false);</code></pre>

        <h3>isEditable(selector)</h3>
        <p><code>true</code> for <code>&lt;input&gt;</code> or <code>&lt;textarea&gt;</code> that is not disabled and not readonly; also <code>true</code> for <code>contenteditable</code> elements.</p>
        <pre><code>const canEdit = await browser.isEditable('name="email"');</code></pre>

        <h3>isSelected(selector)</h3>
        <ul>
          <li><strong>Checkbox / radio:</strong> <code>true</code> if <code>checked</code>.</li>
          <li><strong><code>&lt;option&gt;</code>:</strong> <code>true</code> if that option is selected.</li>
          <li><strong><code>&lt;select&gt;</code>:</strong> <code>true</code> if the select has at least one selected option (<code>selectedIndex >= 0</code>).</li>
        </ul>
        <pre><code>const checked = await browser.locator('#tuesday').isSelected();
expect(checked).toBe(true);

const hasSelection = await browser.isSelected('#country');
const optionSelected = await browser.locator('#country option[value="uk"]').isSelected();</code></pre>

        <hr />
        <h3>Summary</h3>
        <table class="docs-table">
          <thead>
            <tr>
              <th>#</th>
              <th>Method</th>
              <th>Use when</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>1</td>
              <td><code>browser.isVisible(selector)</code></td>
              <td>Check if element exists and is visible</td>
            </tr>
            <tr>
              <td>2</td>
              <td><code>browser.isDisabled(selector)</code></td>
              <td>Check if element is disabled</td>
            </tr>
            <tr>
              <td>3</td>
              <td><code>browser.isEditable(selector)</code></td>
              <td>Check if input/textarea/contenteditable is editable</td>
            </tr>
            <tr>
              <td>4</td>
              <td><code>browser.isSelected(selector)</code></td>
              <td>Check if checkbox/radio/option is selected, or select has selection</td>
            </tr>
          </tbody>
        </table>
        <p>You can also use a locator: <code>browser.locator(selector).isVisible()</code>, <code>.isDisabled()</code>, <code>.isEditable()</code>, <code>.isSelected()</code> (e.g. with <code>.first()</code> or <code>.nth(n)</code> when multiple elements match).</p>

        <h2 id="locators">Locators</h2>
        <p><strong>Introduction</strong> — Locators are how you find element(s) on the page. Every action (<code>click</code>, <code>type</code>, <code>select</code>, <code>check</code>, etc.) and state check (<code>isVisible</code>, <code>isDisabled</code>, <code>isSelected</code>) takes a selector or uses a locator. When you use a locator, the element is resolved at the moment of the action, so if the DOM changes (e.g. re-render), the next action uses the current match.</p>

        <p><strong>Quick guide</strong> — CSTesting supports:</p>
        <table class="docs-table">
          <thead>
            <tr>
              <th>Use case</th>
              <th>How in CSTesting</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>By <strong>role</strong> (e.g. button with text)</td>
              <td>XPath: <code>//button[text()="Sign in"]</code>, or CSS <code>button</code> + <code>.first()</code> if needed</td>
            </tr>
            <tr>
              <td>By <strong>label</strong> (form control)</td>
              <td><code>name="userName"</code> (shorthand) or <code>getByAttribute('name', 'userName')</code>; for label text use XPath: <code>//label[contains(.,"Password")]/following-sibling::input</code> or similar</td>
            </tr>
            <tr>
              <td>By <strong>placeholder</strong></td>
              <td><code>placeholder="name@example.com"</code> (shorthand) or <code>getByAttribute('placeholder', '...')</code></td>
            </tr>
            <tr>
              <td>By <strong>text</strong></td>
              <td>XPath: <code>//*[text()="Welcome"]</code> or <code>//*[contains(text(),"Welcome")]</code></td>
            </tr>
            <tr>
              <td>By <strong>alt text</strong> (images)</td>
              <td><code>getByAttribute('alt', 'logo description')</code> or <code>[alt="..."]</code></td>
            </tr>
            <tr>
              <td>By <strong>title</strong></td>
              <td><code>getByAttribute('title', '...')</code> or <code>[title="..."]</code></td>
            </tr>
            <tr>
              <td>By <strong>test id</strong></td>
              <td><code>getByAttribute('data-testid', 'submit-btn')</code> or <code>[data-testid="submit-btn"]</code></td>
            </tr>
          </tbody>
        </table>

        <p><strong>Selector shorthand</strong> (for <code>locator()</code>, <code>click()</code>, <code>type()</code>, and all actions):</p>
        <ul>
          <li><code>name="userName"</code> → <code>[name="userName"]</code></li>
          <li><code>id="userName"</code> → <code>[id="userName"]</code></li>
          <li><code>class="userName"</code> → <code>.userName</code></li>
          <li>Any <strong>attribute:</strong> <code>placeholder="Enter Name"</code> → <code>[placeholder="Enter Name"]</code></li>
          <li>Anything else → <strong>CSS selector</strong></li>
          <li>Selector starting with <code>/</code> or <code>(</code> → <strong>XPath</strong> (e.g. <code>//button[text()="Sign in"]</code>, <code>(//div)[1]</code>)</li>
        </ul>

        <p><strong>Strict mode</strong> — If the selector matches <strong>0</strong> elements, an error is thrown. If it matches <strong>2 or more</strong>, an error suggests using <code>.first()</code>, <code>.last()</code>, or <code>.nth(n)</code> so the intent is explicit.</p>

        <p><strong>When multiple elements match</strong> — Use a locator and narrow:</p>
        <ul>
          <li><code>browser.locator('button').first().click()</code> — first match</li>
          <li><code>browser.locator('button').last().click()</code> — last match</li>
          <li><code>browser.locator('button').nth(1).click()</code> — second match (0-based)</li>
        </ul>

        <p><strong>Chaining</strong> — You can chain from a frame: <code>browser.frame('iframe#form').locator('input').type('hello')</code>. Locators support <code>.click()</code>, <code>.type(text)</code>, <code>.select(option)</code>, <code>.check()</code>, <code>.uncheck()</code>, <code>.pressKey(key)</code>, <code>.isVisible()</code>, <code>.isDisabled()</code>, <code>.isEditable()</code>, <code>.isSelected()</code>, <code>.textContent()</code>, <code>.getAttribute(name)</code>.</p>

        <p><strong>Example</strong> — Locate by label-like attribute, then act:</p>
        <pre><code>await browser.getByAttribute('name', 'userName').type('mercury');
await browser.getByAttribute('name', 'password').type('secret');
await browser.locator('//button[text()="Sign in"]').click();
const visible = await browser.locator('//*[contains(text(),"Welcome")]').isVisible();
expect(visible).toBe(true);</code></pre>

        <p><strong>Locate by role (button, checkbox, etc.)</strong> — Use XPath or CSS that matches the element and its accessible name:</p>
        <pre><code>// Button with exact text
await browser.locator('//button[text()="Sign in"]').click();

// Checkbox with label (match input near label text)
await browser.locator('//label[contains(.,"Subscribe")]//input').check();

// Heading
const heading = await browser.locator('//h3[text()="Sign up"]').textContent();</code></pre>

        <p><strong>Locate by placeholder</strong> — Use the shorthand or <code>getByAttribute</code>:</p>
        <pre><code>await browser.locator('placeholder="name@example.com"').type('user@test.com');
// or
await browser.getByAttribute('placeholder', 'name@example.com').type('user@test.com');</code></pre>

        <p><strong>Locate by text</strong> — Use XPath for elements by their text content:</p>
        <pre><code>await expect(await browser.locator('//*[contains(text(),"Welcome, John")]').isVisible()).toBe(true);</code></pre>

        <p><strong>Locate by test id</strong> — Prefer <code>data-testid</code> (or a custom attribute) for stable selectors:</p>
        <pre><code>await browser.getByAttribute('data-testid', 'submit-btn').click();</code></pre>

        <h2 id="frames">Frames</h2>
        <p><strong>Introduction</strong> — A page has one main frame; page-level interactions (<code>click</code>, <code>type</code>, etc.) run in the main frame. A page can have additional frames attached via <code>&lt;iframe&gt;</code>. You can get a <strong>frame handle</strong> and interact inside the frame without switching the main page. CSTesting supports <strong>same-origin</strong> iframes only (uses the frame's <code>contentDocument</code>).</p>

        <p><strong>Locate element inside a frame</strong> — Use <code>browser.frame(iframeSelector).locator(selector)</code> to get a locator that runs inside the frame, then call <code>.type()</code>, <code>.click()</code>, etc.:</p>
        <pre><code>const frame = browser.frame('.frame-class');   // or iframe[name="frame-login"], iframe#myframe
await frame.locator('[name="userName"]').type('John');
await frame.locator('[name="password"]').type('secret');
await frame.locator('//button[text()="Sign in"]').click();</code></pre>
        <p>Or use the frame handle's methods directly with a selector:</p>
        <pre><code>await frame.type('[name="userName"]', 'John');
await frame.type('[name="password"]', 'secret');
await frame.click('//button[text()="Sign in"]');</code></pre>

        <p><strong>Frame objects</strong> — Get a frame with <code>browser.frame(selector)</code>. The selector can target the iframe by <strong>id</strong>, <strong>name</strong>, <strong>class</strong>, or any CSS/XPath:</p>
        <pre><code>// By frame's name attribute
const frame = browser.frame('iframe[name="frame-login"]');
// or XPath: browser.frame('//iframe[@name="frame-login"]')

// By id or class
const frame = browser.frame('iframe#myframe');
const frame = browser.frame('.frame-class');

// Interact inside the frame (same API as page: click, type, locator, evaluate, content, select, check, etc.)
await frame.type('[name="username-input"]', 'John');
await frame.click('button');</code></pre>

        <p><strong>Nested frames</strong> — Use <code>.frame(selector)</code> on a frame handle to target an iframe inside that frame:</p>
        <pre><code>const outer = browser.frame('iframe#outer');
const inner = outer.frame('iframe#inner');
await inner.click('button');
// or in one go: browser.frame('iframe#outer').frame('iframe#inner').click('button');</code></pre>

        <p><strong>Late-loading inner frame</strong> — If the inner iframe loads after the page, use <code>frame.waitForSelector(selector, { timeout })</code> before interacting:</p>
        <pre><code>const inner = browser.frame('iframe#outer').frame('iframe#inner');
await inner.waitForSelector('button', { timeout: 10000 });
await inner.click('button');</code></pre>

        <h2 id="dialogs">Dialogs</h2>
        <p><strong>Introduction</strong> — CSTesting can interact with JavaScript dialogs: <strong>alert</strong>, <strong>confirm</strong>, <strong>prompt</strong>, and <strong>beforeunload</strong>. Dialogs are handled in the same CDP session (no <code>switchTo().alert()</code>). You register a <strong>dialog handler</strong> with <code>browser.setDialogHandler(handler)</code> so that when a dialog opens, your handler decides whether to accept or dismiss it (and, for prompt, what text to send).</p>

        <p><strong>alert(), confirm(), prompt()</strong> — By default, all dialogs are <strong>auto-dismissed</strong> (accepted): you don't have to set a handler. To control the behaviour, register a handler <strong>before</strong> the action that triggers the dialog. The handler receives <code>{ type, message }</code> and must return <code>{ accept: true }</code> or <code>{ accept: false }</code> (and for prompt, optional <code>promptText</code>):</p>
        <pre><code>browser.setDialogHandler(({ type, message }) => ({ accept: true }));
await browser.locator('//button[text()="Submit"]').click();</code></pre>

        <p><strong>Note</strong> — The dialog handler <strong>must</strong> handle the dialog (return accept/dismiss). Dialogs are modal and block page execution until handled. If your handler does not respond (e.g. you only log the message), the action that triggered the dialog will <strong>stall</strong> and never resolve.</p>

        <p><strong>Wrong</strong> — Do not only log and leave the dialog unhandled:</p>
        <pre><code>// WRONG: click will hang because the dialog is never accepted/dismissed
browser.setDialogHandler(({ message }) => console.log(message));
await browser.click('button');  // stalls</code></pre>

        <p><strong>Correct</strong> — Always return a result:</p>
        <pre><code>browser.setDialogHandler(({ type, message }) => ({
  accept: true,
  promptText: type === 'prompt' ? 'my value' : undefined,
}));</code></pre>

        <p><strong>Dismiss (Cancel)</strong> — Return <code>accept: false</code> to dismiss confirm/prompt:</p>
        <pre><code>browser.setDialogHandler(() => ({ accept: false }));</code></pre>

        <p><strong>Reset to default</strong> — <code>browser.setDialogHandler(null)</code> restores default behaviour (accept all; prompt gets <code>''</code>).</p>

        <p><strong>beforeunload</strong> — When the page fires a beforeunload dialog (e.g. on leave), the handler receives <code>type === 'beforeunload'</code>. Return <code>{ accept: true }</code> to accept or <code>{ accept: false }</code> to dismiss:</p>
        <pre><code>browser.setDialogHandler(({ type }) => ({
  accept: type !== 'beforeunload',   // dismiss beforeunload, accept others
}));</code></pre>

        <p><strong>Print dialogs</strong> — To assert that <strong>window.print()</strong> was triggered (e.g. after clicking "Print"), you can replace <code>window.print</code> and then wait for it to be called:</p>
        <pre><code>await browser.goto('https://example.com/page-with-print');
// Replace window.print so we can detect when it's called
await browser.evaluate(`
  window._printCalled = false;
  window.print = () => { window._printCalled = true; };
`);
await browser.locator('//button[text()="Print it!"]').click();
// Poll until print was invoked (or use a short sleep and then check)
const printCalled = await browser.evaluate('window._printCalled');
expect(printCalled).toBe(true);</code></pre>
        <p>For a more robust wait, poll in a loop with <code>browser.evaluate('window._printCalled')</code> and <code>browser.sleep(100)</code> until <code>true</code> or a timeout.</p>

        <hr />
        <p><strong>New tab</strong> — <code>waitForNewTab()</code> returns a <strong>TabHandle</strong> (page-like object). Use <strong>browser</strong> for the parent and <strong>newTab</strong> for the new tab <strong>without switching</strong>:</p>
        <pre><code>const [newTab] = await Promise.all([
  browser.waitForNewTab(),
  browser.click('a[target="_blank"]'),
]);

// Parent: use browser (stays on parent)
const parentTitle = await browser.evaluate('document.title');

// New tab: use newTab handle (same API: evaluate, click, content, locator, etc.)
const newTabTitle = await newTab.evaluate('document.title');
await newTab.click('button');
// Optional: close only the new tab's connection
await newTab.close();</code></pre>

        <p><strong>Switching tabs</strong> — To move the main browser to another tab: <code>await browser.switchToTab(1)</code> or <code>await browser.switchToTab(tabId)</code>. List tabs: <code>const tabs = await browser.getTabs();</code></p>

        <p><strong>Frames</strong> — Use <code>browser.frame(iframeSelector)</code> to get a frame handle; then <code>frame.click()</code>, <code>frame.locator(...).type()</code>, <code>frame.evaluate()</code>, etc. Same-origin iframes only. See the <a href="docs.html#frames">Frames</a> section for nested frames and late-loading inner frames.</p>

        <h2 id="navigations">Navigations</h2>
        <p><strong>Introduction</strong> — CSTesting can navigate to URLs and handle navigations caused by page interactions (e.g. clicking a link or submitting a form).</p>

        <p><strong>Basic navigation</strong> — The simplest form is opening a URL:</p>
        <pre><code>await browser.goto('https://example.com');</code></pre>
        <p>This loads the page and waits for the <strong>load</strong> event. The load event fires when the document and its dependent resources (stylesheets, scripts, iframes, images) have loaded.</p>

        <p><strong>Note</strong> — If the page does a client-side redirect before load, <code>browser.goto()</code> waits for the <strong>redirected</strong> page to fire the load event.</p>

        <p><strong>When is the page loaded?</strong> — Modern pages often do more after the load event: they fetch data lazily, hydrate UI, or load extra scripts. There is no single definition of "fully loaded"; it depends on the app. When can you start interacting?</p>
        <p>In CSTesting you can interact at any time. Actions <strong>auto-wait</strong> for the target element to become actionable (visible, stable, enabled). You don't have to add an explicit "wait for page ready" in the general case.</p>
        <pre><code>await browser.goto('https://example.com');
await browser.locator('//*[contains(text(),"Example Domain")]').click();  // click auto-waits for the element</code></pre>
        <p>CSTesting behaves like a fast user: as soon as the element is ready, it acts. You usually don't need to worry about every resource having loaded.</p>

        <p><strong>Hydration</strong> — Sometimes you'll see a click or typed text that seems to have no effect (or the text disappears). A common cause is <strong>poor page hydration</strong>: the server sends static HTML, then JavaScript runs and "hydrates" the page. If you interact before hydration finishes, the button may be visible and clickable in the DOM but its listeners aren't attached yet, so the click does nothing or the input is reset.</p>
        <p>A simple check: in Chrome DevTools, enable "Slow 3G" in the Network panel and reload. If clicks are ignored or typed text is cleared, the page likely has a hydration timing issue. The fix is on the app side: disable interactive controls until after hydration, or ensure they are only enabled when the page is fully functional.</p>

        <p><strong>Waiting for navigation</strong> — A click (e.g. submit, link) can trigger a navigation. You can wait for the new page in three ways:</p>
        <ol>
          <li><strong><code>browser.waitForURL(urlOrPattern, { timeout? })</code></strong> — Wait until the page URL matches. Use a substring, a glob like <code>'**/login'</code>, or a RegExp.</li>
          <li><strong><code>browser.waitForLoad()</code></strong> — Wait for the next <strong>load</strong> event (full document load after navigation).</li>
          <li><strong><code>browser.waitForSelector(selector, { timeout })</code></strong> — Wait for an element that appears only on the new page (e.g. a login form or a success message).</li>
        </ol>
        <pre><code>await browser.locator('//button[text()="Click me"]').click();
await browser.waitForURL('**/login');   // wait until URL contains /login (glob: ** becomes .*)

// Or by substring or RegExp:
await browser.waitForURL('/dashboard');
await browser.waitForURL(/\/login$/);</code></pre>
        <pre><code>await browser.locator('//button[text()="Submit"]').click();
await browser.waitForLoad();   // wait for the navigated page to load
// or wait for something that only exists on the new page:
await browser.waitForSelector('h1', { timeout: 10000 });</code></pre>

        <p><strong>Navigation and loading</strong> — Showing a new document involves <strong>navigation</strong> and <strong>loading</strong>.</p>
        <ul>
          <li><strong>Navigation</strong> starts when the URL changes or you interact (e.g. click a link). It can fail (e.g. DNS error) or turn into a download. When the response headers are in and session history is updated, the navigation is <strong>committed</strong>; only then does <strong>loading</strong> start.</li>
          <li><strong>Loading</strong> is receiving the response body, parsing the document, running scripts, and firing events:
            <ul>
              <li>The page URL is set to the new URL</li>
              <li>Document content is loaded and parsed</li>
              <li><code>DOMContentLoaded</code> fires (when the HTML is parsed; scripts may still run)</li>
              <li>Scripts run and resources (styles, images) load</li>
              <li>The <strong>load</strong> event fires when the document and its subresources are done</li>
            </ul>
          </li>
        </ul>
        <p><code>browser.goto(url)</code> waits for the <strong>load</strong> event. After a click that navigates, use <code>browser.waitForURL('**/login')</code>, <code>browser.waitForLoad()</code>, or <code>waitForSelector</code> to wait for the new page.</p>

        </div>
      </div>
    </main>
  </div>

  <footer class="footer docs-content-footer" id="docs-footer">
    <div class="container">
      <div class="footer-grid">
        <div class="footer-col">
          <h4>Learn</h4>
          <ul>
            <li><a href="docs.html">Getting started</a></li>
            <li><a href="docs.html">Guides</a></li>
          </ul>
        </div>
        <div class="footer-col">
          <h4>Community</h4>
          <ul>
            <li><a href="https://github.com/lokesh771988/EasyTesting" target="_blank" rel="noopener noreferrer">GitHub</a></li>
          </ul>
        </div>
      </div>
      <p class="footer-copy">&copy; 2025 CSTesting. All rights reserved.</p>
    </div>
  </footer>

  <script src="script.js"></script>
  <script>
    (function() {
      var toggle = document.querySelector('.docs-sidebar-toggle');
      var sidebar = document.getElementById('docs-sidebar');
      if (toggle && sidebar) {
        toggle.addEventListener('click', function() {
          var open = sidebar.classList.toggle('is-open');
          toggle.setAttribute('aria-expanded', open);
        });
      }
      document.querySelectorAll('.docs-nav-group-title').forEach(function(btn) {
        btn.addEventListener('click', function() {
          var group = btn.closest('.docs-nav-group');
          var expanded = btn.getAttribute('aria-expanded') === 'true';
          document.querySelectorAll('.docs-nav-group').forEach(function(other) {
            if (other !== group) {
              other.classList.add('collapsed');
              var otherBtn = other.querySelector('.docs-nav-group-title');
              if (otherBtn) otherBtn.setAttribute('aria-expanded', 'false');
            }
          });
          btn.setAttribute('aria-expanded', !expanded);
          group.classList.toggle('collapsed', expanded);
        });
      });

      function syncSidebarToHash() {
        var hash = window.location.hash.slice(1);
        var groups = document.querySelectorAll('.docs-nav-group');
        var activeGroup = null;
        groups.forEach(function(group) {
          var links = group.querySelectorAll('a.docs-nav-link');
          for (var i = 0; i < links.length; i++) {
            var href = links[i].getAttribute('href') || '';
            var linkHash = href.indexOf('#') !== -1 ? href.slice(href.indexOf('#') + 1) : '';
            if (hash && linkHash === hash) {
              activeGroup = group;
              break;
            }
          }
        });
        if (!hash) activeGroup = document.querySelector('.docs-nav-group');
        groups.forEach(function(group) {
          var btn = group.querySelector('.docs-nav-group-title');
          if (btn) {
            var isOpen = group === activeGroup;
            group.classList.toggle('collapsed', !isOpen);
            btn.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
          }
        });
        document.querySelectorAll('.docs-nav-link').forEach(function(a) {
          var href = a.getAttribute('href') || '';
          var linkHash = href.indexOf('#') !== -1 ? href.slice(href.indexOf('#') + 1) : '';
          a.classList.toggle('docs-nav-link--active', hash && linkHash === hash);
        });
      }
      syncSidebarToHash();
      window.addEventListener('hashchange', syncSidebarToHash);

      var logoText = document.getElementById('logo-text');
      var platformBadge = document.getElementById('docs-platform-badge');
      var docsIntro = document.getElementById('docs-intro');
      var docsMainContent = document.getElementById('docs-main-content');
      var docsComingSoonBlock = document.getElementById('docs-coming-soon-block');
      var docsComingSoonMessage = document.getElementById('docs-coming-soon-message');
      var platform = '';
      try {
        platform = sessionStorage.getItem('cstesting-platform') || '';
      } catch (e) {}

      var platformsWithDocs = ['NodeJS'];
      var hasDocs = !platform || platformsWithDocs.indexOf(platform) !== -1;

      if (platform && logoText) {
        logoText.textContent = 'CSTesting for ' + platform;
      }

      if (hasDocs) {
        if (docsMainContent) docsMainContent.style.display = 'block';
        if (docsComingSoonBlock) docsComingSoonBlock.style.display = 'none';
        if (platform && platformBadge) {
          platformBadge.style.display = 'block';
          platformBadge.textContent = 'Documentation for CSTesting for ' + platform;
        }
        if (platform === 'NodeJS' && docsIntro) {
          docsIntro.textContent = 'CSTesting for Node.js is a simple, extensible testing framework. It bundles a test runner, assertions, and CDP-based browser automation (no Playwright or Cypress required). Use JavaScript or TypeScript in your Node.js project.';
        } else if (platform && docsIntro) {
          docsIntro.textContent = 'CSTesting for ' + platform + ' brings the same test runner and browser automation to your stack. This documentation covers installation and usage for ' + platform + '.';
        }
      } else {
        if (docsMainContent) docsMainContent.style.display = 'none';
        if (docsComingSoonBlock) docsComingSoonBlock.style.display = 'block';
        if (platformBadge) platformBadge.style.display = 'none';
        if (docsComingSoonMessage) {
          docsComingSoonMessage.textContent = 'Documentation for CSTesting for ' + platform + ' is coming soon.';
        }
        var switchNodeBtn = document.getElementById('docs-switch-nodejs');
        if (switchNodeBtn) {
          switchNodeBtn.addEventListener('click', function(e) {
            e.preventDefault();
            try { sessionStorage.setItem('cstesting-platform', 'NodeJS'); } catch (err) {}
            window.location.href = 'docs.html';
          });
        }
      }

      var docsFooter = document.getElementById('docs-footer');
      var docsSidebar = document.getElementById('docs-sidebar');
      var docsContent = document.querySelector('.docs-content');
      var footerVisible = false;
      var scrollTick = null;
      var SHOW_THRESHOLD = 12;
      var HIDE_THRESHOLD = 60;
      function isAtBottom(el, threshold) {
        if (!el) return true;
        if (el.scrollHeight <= el.clientHeight) return true;
        var fromBottom = el.scrollHeight - (el.scrollTop + el.clientHeight);
        var limit = threshold === 'hide' ? HIDE_THRESHOLD : SHOW_THRESHOLD;
        return fromBottom <= limit;
      }
      function updateFooterVisibility() {
        if (!docsFooter) return;
        var leftOk = isAtBottom(docsSidebar, footerVisible ? 'hide' : 'show');
        var rightOk = isAtBottom(docsContent, footerVisible ? 'hide' : 'show');
        var shouldShow = leftOk && rightOk;
        if (shouldShow !== footerVisible) {
          footerVisible = shouldShow;
          docsFooter.classList.toggle('is-visible', shouldShow);
        }
      }
      function onScroll() {
        if (scrollTick) return;
        scrollTick = requestAnimationFrame(function() {
          scrollTick = null;
          updateFooterVisibility();
        });
      }
      if (docsFooter && (docsSidebar || docsContent)) {
        if (docsSidebar) docsSidebar.addEventListener('scroll', onScroll);
        if (docsContent) docsContent.addEventListener('scroll', onScroll);
        updateFooterVisibility();
      }
    })();
  </script>
</body>
</html>
